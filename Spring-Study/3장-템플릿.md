# **2주차 - 3장.템플릿**

## **목차**
[1. 전략 패턴](#1.-전략-패턴)<br>
[2. 템플릿 콜백 패턴](#2.-템플릿-콜백-패턴)<br>
[3. 전략 패턴 vs 템플릿 콜백 패턴](#3.-전략-패턴-vs-템플릿-콜백-패턴)<br>
<br>


## **1. 전략 패턴**
 - 패턴이 사용되는 경우
   - 한 행위를 다양하게 수행해야 하는 경우
   - 실행시간까지 객체의 행위 방법을 결정할 수 없는 경우
   - 행위를 수행하는 방법을 쉽게 추가하고 싶은 경우
   - 행위를 추가하면서 코드의 크기를 효과적으로 관리하고 싶은 경우<br> <br>
   
 - 패턴의 구조
   1. **전략 interface** : 전략 메소드의 골격이 선언되어있는 interface
   2. **전략 클래스** : 전략이 구체적으로 구현되어 있는 클래스
   3. **클라이언트 클래스** : 전략을 활용하는 클래스<br>
   <br>

 - 클라이언트는 전략 객체를 유지하기 위한 전략 멤버 변수를 가지고 있음
 - 전략 객체를 이용하여 수행되는 행위(메소드)를 가지고 있음
 - 전략은 생성자를 통해 의존관계를 주입함
---
<br>

## **2. 템플릿 콜백 패턴**
 - 전략 패턴에 익명 클래스(또는 함수)를 더하여 사용하는 패턴<br>

 - lambda를 사용하여 Interface만 구현한 채, 실제 로직을 구현하는 방식<br>

 - 패턴의 구조
   1. **클라이언트 클래스** : 콜백을 생성하여 템플릿을 호출함
   2. **템플릿 interface** : 콜백 함수를 호출하여 참조 정보를 전달
   3. **콜백(Callback)** : 클라이언트의 final 변수를 참조하여 작업을 수행 

 - 패턴의 작업 흐름
   1. 클라이언트에서 Callback 생성
   2. Template으로 Callback을 전달하며, Template 호출
   3. Template에서 Workflow 시작
   4. 참조 정보를 바탕으로 Callback에게 작업 수행
   5. Callback의 작업 결과를 바탕으로 Workflow 진행 후 결과를 반환
 ---
<br>

## **3. 전략 패턴 vs 템플릿 콜백 패턴**
 - 템플릿 콜백 패턴은 전략 패턴에 익명 클래스를 더하여 사용함
 - 전략 패턴에서 정의했던 다양한 클래스들을 클라이언트나 Context에 포함
---
<br>